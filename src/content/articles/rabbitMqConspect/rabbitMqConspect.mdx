---
title: "RabbitMq основы"
date: "2024-11-24"
tags: ["RabbitMQ", "Russian Translation"]
---

# RabbitMQ. Начало.

## Обзор протокола AMQP

RabbitMQ реализует стандартный AMQP (Advanced Message Queuing Protocol) протокол. Дополнительно RabbitMQ поддерживает STOMP, MQTT.

AMQP протокол, предназначенный для отправки сообщений в очередь.

Очередь Queue используется как промежуточное хранилище для сообщений.

Соединение Connection создается между сервисом и AMQP брокером очередей.

Канал Channel виртуальное соединение внутри соединения Connection. Все сообщения внутри системы всегда пересылаются через канал.
Каналы являются мультиплексными - т.е. одно соединение может иметь несколько каналов.

Сообщения не публикуются в очередь Queue напрямую.
Вместо этого, отправитель producer шлет сообщение в модуль Exchange.
Exchange - маршрутизатор, который направляет сообщение в нужную очередь.
Сообщения направляются в очереди Queues, на основании привязки Bindings между очередями Queues и маршрутизаторами Exchanges с помощью ключа маршрутизации Routing Key.

Ключ маршрутизации Routing Key - первое, на что смотрит маршрутизатор Exchange, когда определяет в какую очередь направить сообщение.

Кроме основного контента каждое сообщение содержит набор заголовков таких как durability и priority.

AMQP ясно дает понять когда сообщение отправлено из одного сервиса другому.
Это реализовано через команды acknowledge - подтверждающие что сообщение передано и обработано.

Вирутальные хосты Virtual hosts, или vhosts, предоставляют возможность разделить приложения в брокере.
Права пользователей для разных vhosts могут варьироваться, а очереди Queues и маршрутизаторы Exchanges существуют только в определенном vhost.

## Соединения и каналы

Соединение - это связь между клиентом Client и брокером Broker, которая под капотом выполняет разные сетевые задачи. Такие задачи как аутентификация, получение IP, и общение по сети. RabbitMQ поддерживает как IPv4 так и IPv6 соединения. Также есть возможность шифровать соединение, используя TLS.

Соединение может разделяться на несколько “легковесных коннектов”. Такой "легковесный коннект" называется каналом. Каждое соединение Connection может поддерживать набор каналов Channels. Обычно сервису нужно иметь несколько соединений с брокером, bно вместо множества тяжелых коннектов, сервис может переиспользовать или удалять каналы Channels.

Канал переиспользует соединение, без необходимости повторной авторизации и открытия потока TCP. Каналы Channels просто позволяют использовать ресурсы более эффективно. Каждая операция AMQP протокола проводится через канал Channel.

Соединение Connection создается когда открываем коннект TCP на сервер. Клиент получает имена хостов для адресов IP перед тем как обменяться пакетами. Сервер аутентифицирует клиента.

Чтобы отправить сообщение или управлять очередью, необходимо установить канал Channel. Канал упаковывает сообщения и поддерживает разные операции протокола. Клиент отправляет сообщения с помощью метода канала "basic_publish".

Создание и управление очередями тоже делается через канал. Через него отправляются AMQP команды "queue.create" и "exchange.create". При закрытии соединения закрываются все его каналы.

Канал может быть открыт сразу после установления соединения.

## Очереди Queues

Очередь - хранилище сообщений, где они находятся, пока их не заберет потребитель - consumer, либо пока их не уберут из очреди другим способом.
У очередей есть сво стива, определяющие их поведение, и эти свойства передаются при создании очереди.

Есть обязательные свойства и опциональные. У очереди всегда есьть название, на которое потом будут ссылаться сервисы.
В большинстве библиотек очередь, объявлемая без имени, получит рандомное название.

Очередь может быть отмечена атрибутом durable, это означает что очередь должна сохраниться после рестарта брокера.

Очередь может быть отмечена атрибутом exclusive, значит она будет использоваться лишь одним конкретным соединением connection. Такая очередь будет удалена после того как закроется соединение.

Очередь может быть отмечена атрибутом auto-delete, значит она будет удалена автоматически когда последний потребитель отпишется от нее.

Есть несколько опциональных свойств, которые предназначены для плагинов и возможностей брокера, например TTL - период, в течение которого неиспользуемая очередь будет отмечена как неактуальная (expired).

Перед использованием очереди ее нужно объявить. Объявление очереди подразумевает ее создание, если ее еще не существует.

Жизненный цикл временной очереди.

Клиент создает очередь сообщений (Declare). Сервер подтверждает что все ок (Declare-Ok).
Клиент запускает потребителя для очереди сообщений.
Клиент удаляет потребителя, это можно сделать явно или закрытием канала и/или соединения.
Когда последний потребитель очереди будет удален, сервер удалит очередь сообщений.

## Маршрутизаторы Exchanges

Теоритически, маршрутизатор первая точка входа сообщения, которое попадает в брокер. Сообщения не отправляются напрямую в очередь. Вместо этого отправитель шлет сообщения в Exchange, который представляет собой маршрутизатор. Его ответственность направить сообщение в нужную очередь, используя заголовки - header attributes, привязки - bindings, и ключи маршрутизации - routing keys.

Также как и очереди, маршрутизаторы при создании настраиваются через параметры durable, temporary, и auto-delete. Durable - переживет перезапуск брокера. Temporary существует до тех пор, пока RabbitMQ не выключится. Auto-deleted будет удален, когда последний объект будет отвязан от маршрутизатора.

Жизненный цикл маршрутизатора.

Клиент делает запрос чтобы убедиться что маршрутизатор существует. Маршрутизатор будет создан, если его еще не существует.
Клиент отправляет сообщения в маршрутизатор.
Клиент может удалиь маршрутизатор.
В RabbitMQ существует 4 разных типа маршрутизаторов, которые распределяют сообщения, используя разные параметры и установленные привязки.
Клиент может создавать собственные маршрутизаторы или использовать уже предустановленные.

## Привязки Bindings

Привязка binding служит связью между очередью и маршрутизатором. С помощью нее можно понять какая очередь будет получать сообщения от определенного маршрутизатора. Привязки могут принимать дополнительный параметр routing_key. Как вы помните, ключ маршрутизации routing key также может прикрепляться к сообщению. Ключ привязки и ключ маршрутизации - параметры колторые определяют куда будет направлено сообщение.

channel.queue_bind(exchange=exchange_name, queue=queue_name, routing_key='black')

## Consumer Acknowledgements и Publisher Confirm

При передаче сообщения могут потеряться, если отвалилось соединение. Их нужно переотправить. 

Acknowledgments - подтверждения позволяют серверу и клиенту понять когда нужно переотправить сообщение.

Клиент может подтвердить сообщение либо сразу как получит его, либо когда полностью его обработает.

Publish confirm - такой же механизм подтверждения только для отправления.

Сервер подтвердит сообщение, сразу как получит его от отправителя.

Сообщение можно считать успешно доставленным по разному:
- Как только его отправили
- Как только оно записалось в TCP сокет
- Когда получено явное подтверждение с клиента

Ручное подтвердение может быть позитивным или негативным

Как только получено подтверждение, сообщение можно убрать из очереди 

Если получатель не смог обработать сообщение:
- Можно переслать его в очередь и позволить другому получателю обработать его
- Можно повторить обработку позже

Такие отправления могут исключаться сервером либо переотправляться.
Это поведение контролируется полем `requeue`.
`requeue = true` - брокер запаланирует переотправку.
Переотправляемое сообщение вернется на его место в очереди, если возможно, и будет готово к повторной доставке.
Если все получатели будут отправлять сообщения обратно в очередь, потому что не  смогли обработать доставку -  будут проблемы с постоянной переотправкой
Есть возможность отслеживать количество переотправок и выкидывать такие сообщения из очереди, либо планировать переотправку через выдержку по времени.

