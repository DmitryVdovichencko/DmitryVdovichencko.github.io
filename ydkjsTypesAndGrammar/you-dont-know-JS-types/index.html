<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.523a32149e440def5b67.css" data-identity="gatsby-global-css">@import url(https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&display=swap);
/*
! tailwindcss v3.3.3 | MIT License | https://tailwindcss.com
*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-feature-settings:normal;font-family:Roboto;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{padding-left:1rem;padding-right:1rem;width:100%}@media (min-width:640px){.container{max-width:640px;padding-left:2rem;padding-right:2rem}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px;padding-left:4rem;padding-right:4rem}}@media (min-width:1280px){.container{max-width:1280px;padding-left:5rem;padding-right:5rem}}@media (min-width:1536px){.container{max-width:1536px;padding-left:6rem;padding-right:6rem}}.prose{color:#374151;max-width:65ch}.prose :where(p):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em;margin-top:1.25em}.prose :where([class~=lead]):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-lead);font-size:1.25em;line-height:1.6;margin-bottom:1.2em;margin-top:1.2em}.prose :where(a):not(:where([class~=not-prose],[class~=not-prose] *)){color:#374151;font-weight:300;text-decoration:none}.prose :where(a):not(:where([class~=not-prose],[class~=not-prose] *)):hover{color:#3b82f6!important}.prose :where(a):not(:where([class~=not-prose],[class~=not-prose] *))[aria-current]{font-weight:700!important}.prose :where(strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-bold);font-weight:600}.prose :where(a strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(blockquote strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(thead th strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(ol):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:decimal;margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose :where(ol[type=A]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-alpha}.prose :where(ol[type=a]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-alpha}.prose :where(ol[type=A s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-alpha}.prose :where(ol[type=a s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-alpha}.prose :where(ol[type=I]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-roman}.prose :where(ol[type=i]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-roman}.prose :where(ol[type=I s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:upper-roman}.prose :where(ol[type=i s]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:lower-roman}.prose :where(ol[type="1"]):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:decimal}.prose :where(ul):not(:where([class~=not-prose],[class~=not-prose] *)){list-style-type:disc;margin-bottom:1.25em;margin-top:1.25em;padding-left:1.625em}.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker{color:var(--tw-prose-counters);font-weight:400}.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *))::marker{color:var(--tw-prose-bullets)}.prose :where(dt):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;margin-top:1.25em}.prose :where(hr):not(:where([class~=not-prose],[class~=not-prose] *)){border-color:var(--tw-prose-hr);border-top-width:1px;margin-bottom:3em;margin-top:3em}.prose :where(blockquote):not(:where([class~=not-prose],[class~=not-prose] *)){border-left-color:var(--tw-prose-quote-borders);border-left-width:.25rem;color:var(--tw-prose-quotes);font-style:italic;font-weight:500;margin-bottom:1.6em;margin-top:1.6em;padding-left:1em;quotes:"\201C""\201D""\2018""\2019"}.prose :where(blockquote p:first-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:open-quote}.prose :where(blockquote p:last-of-type):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:close-quote}.prose :where(h1):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-size:2.25em;font-weight:800;line-height:1.1111111;margin-bottom:.8888889em;margin-top:0}.prose :where(h1 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:900}.prose :where(h2):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-size:1.5em;font-weight:700;line-height:1.3333333;margin-bottom:1em;margin-top:2em}.prose :where(h2 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:800}.prose :where(h3):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-size:1.25em;font-weight:600;line-height:1.6;margin-bottom:.6em;margin-top:1.6em}.prose :where(h3 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:700}.prose :where(h4):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;line-height:1.5;margin-bottom:.5em;margin-top:0}.prose :where(h4 strong):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-weight:700}.prose :where(img):not(:where([class~=not-prose],[class~=not-prose] *)){margin:0}.prose :where(picture):not(:where([class~=not-prose],[class~=not-prose] *)){display:block;margin-bottom:2em;margin-top:2em}.prose :where(kbd):not(:where([class~=not-prose],[class~=not-prose] *)){border-radius:.3125rem;box-shadow:0 0 0 1px rgb(var(--tw-prose-kbd-shadows)/10%),0 3px 0 rgb(var(--tw-prose-kbd-shadows)/10%);color:var(--tw-prose-kbd);font-family:inherit;font-size:.875em;font-weight:500;padding:.1875em .375em}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)){background:#e5e7eb;border-radius:2px;color:#374151;font-size:.875em;font-weight:600;padding:.25rem}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:""!important}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:""!important}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:"`"}.prose :where(code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:"`"}.prose :where(a code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(h1 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(h2 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-size:.875em}.prose :where(h3 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit;font-size:.9em}.prose :where(h4 code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(blockquote code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(thead th code):not(:where([class~=not-prose],[class~=not-prose] *)){color:inherit}.prose :where(pre):not(:where([class~=not-prose],[class~=not-prose] *)){background-color:var(--tw-prose-pre-bg);border-radius:.375rem;color:var(--tw-prose-pre-code);font-size:.875em;font-weight:400;line-height:1.7142857;margin-bottom:1.7142857em;margin-top:1.7142857em;overflow-x:auto;padding:.8571429em 1.1428571em}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)){background-color:transparent;border-radius:0;border-width:0;color:inherit;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;padding:0}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):before{content:none}.prose :where(pre code):not(:where([class~=not-prose],[class~=not-prose] *)):after{content:none}.prose :where(table):not(:where([class~=not-prose],[class~=not-prose] *)){font-size:.875em;line-height:1.7142857;margin-bottom:2em;margin-top:2em;table-layout:auto;text-align:left;width:100%}.prose :where(thead):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-color:var(--tw-prose-th-borders);border-bottom-width:1px}.prose :where(thead th):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-headings);font-weight:600;padding-bottom:.5714286em;padding-left:.5714286em;padding-right:.5714286em;vertical-align:bottom}.prose :where(tbody tr):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-color:var(--tw-prose-td-borders);border-bottom-width:1px}.prose :where(tbody tr:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){border-bottom-width:0}.prose :where(tbody td):not(:where([class~=not-prose],[class~=not-prose] *)){vertical-align:baseline}.prose :where(tfoot):not(:where([class~=not-prose],[class~=not-prose] *)){border-top-color:var(--tw-prose-th-borders);border-top-width:1px}.prose :where(tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)){vertical-align:top}.prose :where(figure>*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0;margin-top:0}.prose :where(figcaption):not(:where([class~=not-prose],[class~=not-prose] *)){color:var(--tw-prose-captions);font-size:.875em;line-height:1.4285714;margin-top:.8571429em}.prose{--tw-prose-body:#374151;--tw-prose-headings:#111827;--tw-prose-lead:#4b5563;--tw-prose-links:#111827;--tw-prose-bold:#111827;--tw-prose-counters:#6b7280;--tw-prose-bullets:#d1d5db;--tw-prose-hr:#e5e7eb;--tw-prose-quotes:#111827;--tw-prose-quote-borders:#e5e7eb;--tw-prose-captions:#6b7280;--tw-prose-kbd:#111827;--tw-prose-kbd-shadows:17 24 39;--tw-prose-code:#111827;--tw-prose-pre-code:#e5e7eb;--tw-prose-pre-bg:#1f2937;--tw-prose-th-borders:#d1d5db;--tw-prose-td-borders:#e5e7eb;--tw-prose-invert-body:#d1d5db;--tw-prose-invert-headings:#fff;--tw-prose-invert-lead:#9ca3af;--tw-prose-invert-links:#fff;--tw-prose-invert-bold:#fff;--tw-prose-invert-counters:#9ca3af;--tw-prose-invert-bullets:#4b5563;--tw-prose-invert-hr:#374151;--tw-prose-invert-quotes:#f3f4f6;--tw-prose-invert-quote-borders:#374151;--tw-prose-invert-captions:#9ca3af;--tw-prose-invert-kbd:#fff;--tw-prose-invert-kbd-shadows:255 255 255;--tw-prose-invert-code:#fff;--tw-prose-invert-pre-code:#d1d5db;--tw-prose-invert-pre-bg:rgba(0,0,0,.5);--tw-prose-invert-th-borders:#4b5563;--tw-prose-invert-td-borders:#374151;font-size:1rem;line-height:1.75}.prose :where(picture>img):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0;margin-top:0}.prose :where(video):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:2em;margin-top:2em}.prose :where(li):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:.5em;margin-top:.5em}.prose :where(ol>li):not(:where([class~=not-prose],[class~=not-prose] *)){padding-left:.375em}.prose :where(ul>li):not(:where([class~=not-prose],[class~=not-prose] *)){padding-left:.375em}.prose :where(.prose>ul>li p):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:.75em;margin-top:.75em}.prose :where(.prose>ul>li>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em}.prose :where(.prose>ul>li>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em}.prose :where(.prose>ol>li>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:1.25em}.prose :where(.prose>ol>li>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em}.prose :where(ul ul,ul ol,ol ul,ol ol):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:.75em;margin-top:.75em}.prose :where(dl):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:1.25em;margin-top:1.25em}.prose :where(dd):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:.5em;padding-left:1.625em}.prose :where(hr+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h2+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h3+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(h4+*):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(thead th:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-left:0}.prose :where(thead th:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-right:0}.prose :where(tbody td,tfoot td):not(:where([class~=not-prose],[class~=not-prose] *)){padding:.5714286em}.prose :where(tbody td:first-child,tfoot td:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-left:0}.prose :where(tbody td:last-child,tfoot td:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){padding-right:0}.prose :where(figure):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:2em;margin-top:2em}.prose :where(.prose>:first-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-top:0}.prose :where(.prose>:last-child):not(:where([class~=not-prose],[class~=not-prose] *)){margin-bottom:0}.prose :where(article):not(:where([class~=not-prose],[class~=not-prose] *)) a{color:#3b82f6}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.inset-0{inset:0}.mx-2{margin-left:.5rem;margin-right:.5rem}.mx-auto{margin-left:auto;margin-right:auto}.my-1{margin-bottom:.25rem;margin-top:.25rem}.my-4{margin-bottom:1rem;margin-top:1rem}.my-8{margin-bottom:2rem;margin-top:2rem}.-mb-0{margin-bottom:0}.-mb-0\.5{margin-bottom:-.125rem}.mb-2{margin-bottom:.5rem}.mb-2\.5{margin-bottom:.625rem}.mb-6{margin-bottom:1.5rem}.ml-1{margin-left:.25rem}.ml-2{margin-left:.5rem}.mr-1{margin-right:.25rem}.mr-2{margin-right:.5rem}.mt-0{margin-top:0}.mt-0\.5{margin-top:.125rem}.mt-2{margin-top:.5rem}.mt-4{margin-top:1rem}.flex{display:flex}.inline-flex{display:inline-flex}.h-48{height:12rem}.h-8{height:2rem}.h-full{height:100%}.min-h-screen{min-height:100vh}.w-full{width:100%}.max-w-5xl{max-width:64rem}.flex-1{flex:1 1 0%}.flex-auto{flex:1 1 auto}.flex-none{flex:none}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.content-center{align-content:center}.items-end{align-items:flex-end}.items-center{align-items:center}.items-baseline{align-items:baseline}.justify-start{justify-content:flex-start}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.rounded{border-radius:.25rem}.rounded-lg{border-radius:.5rem}.rounded-t-lg{border-top-left-radius:.5rem;border-top-right-radius:.5rem}.bg-\[\#24292F\]{--tw-bg-opacity:1;background-color:rgb(36 41 47/var(--tw-bg-opacity))}.bg-blue-500{--tw-bg-opacity:1;background-color:rgb(59 130 246/var(--tw-bg-opacity))}.bg-slate-200{--tw-bg-opacity:1;background-color:rgb(226 232 240/var(--tw-bg-opacity))}.object-cover{-o-object-fit:cover;object-fit:cover}.p-4{padding:1rem}.p-6{padding:1.5rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-4{padding-left:1rem;padding-right:1rem}.px-5{padding-left:1.25rem;padding-right:1.25rem}.py-1{padding-bottom:.25rem;padding-top:.25rem}.py-2{padding-bottom:.5rem;padding-top:.5rem}.py-2\.5{padding-bottom:.625rem;padding-top:.625rem}.text-center{text-align:center}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-light{font-weight:300}.font-medium{font-weight:500}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.italic{font-style:italic}.text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity))}.text-stone-600{--tw-text-opacity:1;color:rgb(87 83 78/var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}.shadow-lg{--tw-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -4px rgba(0,0,0,.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color),0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-500{transition-duration:.5s}.ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}body,html{min-height:100vh}.hover\:bg-\[\#24292F\]\/90:hover{background-color:rgba(36,41,47,.9)}.hover\:bg-blue-700:hover{--tw-bg-opacity:1;background-color:rgb(29 78 216/var(--tw-bg-opacity))}.hover\:shadow-xl:hover{--tw-shadow:0 20px 25px -5px rgba(0,0,0,.1),0 8px 10px -6px rgba(0,0,0,.1);--tw-shadow-colored:0 20px 25px -5px var(--tw-shadow-color),0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.focus\:ring-4:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.focus\:ring-\[\#24292F\]\/50:focus{--tw-ring-color:rgba(36,41,47,.5)}@media (prefers-color-scheme:dark){.dark\:hover\:bg-\[\#050708\]\/30:hover{background-color:rgba(5,7,8,.3)}.dark\:focus\:ring-gray-500:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(107 114 128/var(--tw-ring-opacity))}}@media (min-width:768px){.md\:h-auto{height:auto}.md\:w-48{width:12rem}.md\:flex-row{flex-direction:row}.md\:rounded-l-lg{border-bottom-left-radius:.5rem;border-top-left-radius:.5rem}.md\:rounded-t-none{border-top-left-radius:0;border-top-right-radius:0}.md\:pl-6{padding-left:1.5rem}}code[class*=language-],pre[class*=language-]{word-wrap:normal;background:none;color:#ccc;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;text-align:left;white-space:pre;word-break:normal;word-spacing:normal}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#2d2d2d}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.block-comment,.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#999}.token.punctuation{color:#ccc}.token.attr-name,.token.deleted,.token.namespace,.token.tag{color:#e2777a}.token.function-name{color:#6196cc}.token.boolean,.token.function,.token.number{color:#f08d49}.token.class-name,.token.constant,.token.property,.token.symbol{color:#f8c555}.token.atrule,.token.builtin,.token.important,.token.keyword,.token.selector{color:#cc99cd}.token.attr-value,.token.char,.token.regex,.token.string,.token.variable{color:#7ec699}.token.entity,.token.operator,.token.url{color:#67cdcc}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}.token.inserted{color:green}</style><meta name="generator" content="Gatsby 3.15.0"/><style>.gatsby-image-wrapper{position:relative;overflow:hidden}.gatsby-image-wrapper picture.object-fit-polyfill{position:static!important}.gatsby-image-wrapper img{bottom:0;height:100%;left:0;margin:0;max-width:none;padding:0;position:absolute;right:0;top:0;width:100%;object-fit:cover}.gatsby-image-wrapper [data-main-image]{opacity:0;transform:translateZ(0);transition:opacity .25s linear;will-change:opacity}.gatsby-image-wrapper-constrained{display:inline-block;vertical-align:top}</style><noscript><style>.gatsby-image-wrapper noscript [data-main-image]{opacity:1!important}.gatsby-image-wrapper [data-placeholder-image]{opacity:0!important}</style></noscript><script type="module">const e="undefined"!=typeof HTMLImageElement&&"loading"in HTMLImageElement.prototype;e&&document.body.addEventListener("load",(function(e){if(void 0===e.target.dataset.mainImage)return;if(void 0===e.target.dataset.gatsbyImageSsr)return;const t=e.target;let a=null,n=t;for(;null===a&&n;)void 0!==n.parentNode.dataset.gatsbyImageWrapper&&(a=n.parentNode),n=n.parentNode;const o=a.querySelector("[data-placeholder-image]"),r=new Image;r.src=t.currentSrc,r.decode().catch((()=>{})).then((()=>{t.style.opacity=1,o&&(o.style.opacity=0,o.style.transition="opacity 500ms linear")}))}),!0);</script><title data-react-helmet="true">Вы не знаете JS. Типы и грамматика. Глава 2. Типы.</title><meta data-react-helmet="true" name="description" content="Hogwarts Potions master, Head of Slytherin house and former Death Eater."/><meta data-react-helmet="true" name="image" content="https://dimetrio.codes/snape.jpg"/><meta data-react-helmet="true" property="og:url" content="https://dimetrio.codes/ydkjsTypesAndGrammar/you-dont-know-JS-types/"/><meta data-react-helmet="true" property="og:title" content="Вы не знаете JS. Типы и грамматика. Глава 2. Типы."/><meta data-react-helmet="true" property="og:description" content="Hogwarts Potions master, Head of Slytherin house and former Death Eater."/><meta data-react-helmet="true" property="og:image" content="https://dimetrio.codes/snape.jpg"/><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"/><meta data-react-helmet="true" name="twitter:creator" content="@dimetrio89"/><meta data-react-helmet="true" name="twitter:title" content="Вы не знаете JS. Типы и грамматика. Глава 2. Типы."/><meta data-react-helmet="true" name="twitter:description" content="Hogwarts Potions master, Head of Slytherin house and former Death Eater."/><meta data-react-helmet="true" name="twitter:image" content="https://dimetrio.codes/snape.jpg"/><link rel="icon" href="/favicon-32x32.png?v=dd15f4049523a358847321418b9f4959" type="image/png"/><link rel="manifest" href="/manifest.webmanifest" crossorigin="anonymous"/><meta name="theme-color" content="#fff"/><link rel="apple-touch-icon" sizes="48x48" href="/icons/icon-48x48.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="72x72" href="/icons/icon-72x72.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="96x96" href="/icons/icon-96x96.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="144x144" href="/icons/icon-144x144.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="192x192" href="/icons/icon-192x192.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="256x256" href="/icons/icon-256x256.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="384x384" href="/icons/icon-384x384.png?v=dd15f4049523a358847321418b9f4959"/><link rel="apple-touch-icon" sizes="512x512" href="/icons/icon-512x512.png?v=dd15f4049523a358847321418b9f4959"/><link as="script" rel="preload" href="/webpack-runtime-e42de5cee8763d7eed7b.js"/><link as="script" rel="preload" href="/framework-5b393e7059ef32414e1e.js"/><link as="script" rel="preload" href="/app-4598599d5dc989cb3c6d.js"/><link as="script" rel="preload" href="/1bfc9850-24c4e4f8b9c1ce827e99.js"/><link as="script" rel="preload" href="/d7eeaac4-e421a7068fd23f78af03.js"/><link as="script" rel="preload" href="/2af76ce767fe1f5d8aa362c9f068e2f38185524d-f44f3e4c0c25e6e440b6.js"/><link as="script" rel="preload" href="/component---src-templates-article-tsx-78c06980dcd84d0a236d.js"/><link as="fetch" rel="preload" href="/page-data/ydkjsTypesAndGrammar/you-dont-know-JS-types/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/sq/d/4202924991.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="prose container mx-auto max-w-5xl min-h-screen flex flex-col"><header class="flex flex-row flex-wrap w-full justify-between items-end"><a href="/"><h3>Dmitry Vdovichenko</h3></a><nav class="mb-2.5 h-8"><a class="uppercase text-sm font-light" href="/articles/">Articles</a><a class="ml-2 uppercase text-sm font-light" href="/projects/">Projects</a><a class="ml-2 uppercase text-sm font-light" href="/">About</a></nav></header><main class="flex flex-col flex-1"><article><h1>Вы не знаете JS. Типы данных и грамматика. Значения</h1><p>Перевод Главы 2 книги Кайла Симпсона <a href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch2.md">&quot;Вы не знаете JS. Типы данных и грамматика. Значения&quot;</a>.  </p><p><code>array</code>, <code>string</code>, и <code>number</code> являются основными составными элементами любой программы, но в JavaScript, при работе с этими типами данных, есть несколько особенностей, которые могут смутить или запутать вас.</p><p>Давайте посмотрим на несколько встроенных типов JS, и разберемся как мы можем полностью понять и корректно использовать их поведение.</p><h2>Массивы</h2><p>Если сравнивать с другими строго-типизированными языками, в JavaScript массивы - всего  лишь контейнеры для любых типов значений, начиная от  <code>string</code> до <code>number</code> , <code>object</code> и даже других <code>array</code> (с помощью которых можно создавать многомерные массивы).</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>		<span class="token comment">// 3</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">;</span>	<span class="token comment">// true</span></code></pre></div><p>Вам не нужно предварительно устанавливать размер <code>array</code> (подробнее в &quot;Массивы&quot; Глава 3), вы можете просто объявить их и добавлять значения когда вам нужно:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>	<span class="token comment">// 0</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>	<span class="token comment">// 3</span></code></pre></div><p><strong>Предупреждение:</strong> Используя <code>delete</code> для значения <code>array</code> будет удалена ячейка <code>array</code> с этим значением, но даже если вы удалите последний элемент таким способом, это <strong>НЕ</strong> обновит свойство <code>length</code> , так что будьте осторожны! Работа оператора <code>delete</code> более детально будет рассмотрена в Главе 5.</p><p>Будьте осторожны при создании &quot;разрозненных&quot; массивов (оставляя или создавая пустые/пропущенные ячейки):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">// ячейка `a[1]` отсутствует</span>
a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token number">3</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>		<span class="token comment">// undefined</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>	<span class="token comment">// 3</span></code></pre></div><p>Такой код может привести к странному поведению &quot;пустых ячеек&quot; оставленных между элементами массива. Пустой слот со значением <code>undefined</code> внутри, ведет себя не так же как явно объявленный эдемент массива (<code>a[1] = undefined</code>). Подробнее в главе 3 &quot;Массивы&quot;.</p><p>Массивы <code>array</code>s проиндексированы числами (как и ожидается), но хитрость в том, что они могут иметь индекс в виде  строки <code>string</code> ключ/свойство могут быть добавлены к массиву (но такие свойства не будут посчитаны в длине массива <code>length</code>):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a<span class="token punctuation">[</span><span class="token string">&quot;foobar&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>		<span class="token comment">// 1</span>
a<span class="token punctuation">[</span><span class="token string">&quot;foobar&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">// 2</span>
a<span class="token punctuation">.</span>foobar<span class="token punctuation">;</span>		<span class="token comment">// 2</span></code></pre></div><p>Как бы там ни было, нужно быть осторожнее при использовании индексов массива в виде <code>string</code> , т.к. это значение может быть преобразовано в тип <code>number</code>, потому что использование индекса <code>number</code> для массива предпочтительнее чем <code>string</code>!</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token string">&quot;13&quot;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 14</span></code></pre></div><p>В общем, это не самая лучшая идея использовать пару <code>string</code> ключ/свойство как элемент массива <code>array</code>. Используйте <code>object</code> для хранения пар ключ/свойство, а массивы <code>array</code>s приберегите для хранения значений в ячейках с числовыми индексами.</p><h3>Массивоподобные</h3><p>Бывают случаи когда нужно преобразовать  массивоподобное значение (пронумерованную коллекцию значений) в настоящий массив <code>array</code>, обычно таким образом вы сможете применить методы массива (такие как <code>indexOf(..)</code>, <code>concat(..)</code>, <code>forEach(..)</code>, etc.) к коллекции значений.</p><p>Например, различные DOM запросы возвращают список DOM элементов который не является настоящим массивом <code>array</code>, но, при этом он достаточно похож на массив для преобразования. Другой общеизвестный пример - когда функция предоставляет свои аргументы <code>arguments</code> в виде массивоподобного объекта (в ES6, считается устаревшим), чтобы получить доступ к списку аргументов.</p><p>Один из самых распространенных способов осуществить такое преобразование одолжить метод <code>slice(..)</code> для значения:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
	arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token string">&quot;bam&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;baz&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [&quot;bar&quot;,&quot;baz&quot;,&quot;bam&quot;]</span></code></pre></div><p>Если <code>slice()</code> вызван без каких-либо параметров, как в примере выше, стандартные значения его параметров позволят продублировать массив <code>array</code> (а в нашем случае , массивоподобное значение).</p><p>В ES6, есть встроенный метод <code>Array.from(..)</code> который при вызове выполнит то же самое:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token operator">...</span>
<span class="token keyword">var</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span></code></pre></div><p><strong>Примечание:</strong> <code>Array.from(..)</code> имеет несколько мощных возможностей, детально о них рассказано в книге <em>ES6 и не только</em> данной серии.</p><h2>Строки</h2><p>Есть общее мнение, что строки <code>string</code> являются всего лишь массивами <code>array</code> из символов. Пока мы решаем можно или нельзя использовать <code>array</code>, важно осознавать что JavaScript <code>string</code>на самом деле не то же самое что массивы <code>array</code> символов. Это сходство по большей части поверхностное.</p><p>Например, давайте сравним два значения:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;f&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;o&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;o&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre></div><p>Строки имеют поверхностные сходства по отношению к массивам и массивоподобным, такие как -- например, оба из них имеют свойство <code>length</code>,метод <code>indexOf(..)</code> (<code>array</code> только в ES5), и метод <code>concat(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>							<span class="token comment">// 3</span>
b<span class="token punctuation">.</span>length<span class="token punctuation">;</span>							<span class="token comment">// 3</span>

a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span> <span class="token string">&quot;o&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 1</span>
b<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span> <span class="token string">&quot;o&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// 1</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span> <span class="token string">&quot;bar&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// &quot;foobar&quot;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span> <span class="token punctuation">[</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;r&quot;</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;,&quot;b&quot;,&quot;a&quot;,&quot;r&quot;]</span>

a <span class="token operator">===</span> c<span class="token punctuation">;</span>							<span class="token comment">// false</span>
b <span class="token operator">===</span> d<span class="token punctuation">;</span>							<span class="token comment">// false</span>

a<span class="token punctuation">;</span>									<span class="token comment">// &quot;foo&quot;</span>
b<span class="token punctuation">;</span>									<span class="token comment">// [&quot;f&quot;,&quot;o&quot;,&quot;o&quot;]</span></code></pre></div><p>Итак строки по большей части это &quot;массивы символов&quot;, верно? <strong>НЕ совсем</strong>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;O&quot;</span><span class="token punctuation">;</span>
b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;O&quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// &quot;foo&quot;</span>
b<span class="token punctuation">;</span> <span class="token comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;]</span></code></pre></div><p>В JavaScript строки <code>string</code> неизменяемы, тогда как массивы <code>array</code> достаточно изменяемы. Более того форма доступа к символу строки вида <code>a[1]</code>  не совсем правильный JavaScript. Старые версии IE не разрешают такой синтаксис (в новых версиях IE это работает). Вместо него нужно использовать <em>корректный</em> способ -  <code>a.charAt(1)</code>.</p><p>Еще одним подследствием неизменяемости строк <code>string</code> является то что ни один метод строки <code>string</code> меняющий ее содержимое не может делать это по месту, скорее метод создаст и вернет новые строки. И напротив, большинство методов изменяющих содержимое массива <code>array</code> действительно <em>делают</em> изменения по месту.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a <span class="token operator">===</span> c<span class="token punctuation">;</span>	<span class="token comment">// false</span>
a<span class="token punctuation">;</span>			<span class="token comment">// &quot;foo&quot;</span>
c<span class="token punctuation">;</span>			<span class="token comment">// &quot;FOO&quot;</span>

b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token string">&quot;!&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">;</span>			<span class="token comment">// [&quot;f&quot;,&quot;O&quot;,&quot;o&quot;,&quot;!&quot;]</span></code></pre></div><p>Также многие из методов массива <code>array</code>, которые могут быть полезны при работе со строками <code>string</code> вообще для них недоступны, но мы можем &quot;одолжить&quot; неизменяющие методы массива <code>array</code> для нашей строки <code>string</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">.</span>join<span class="token punctuation">;</span>			<span class="token comment">// undefined</span>
a<span class="token punctuation">.</span>map<span class="token punctuation">;</span>			<span class="token comment">// undefined</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token string">&quot;-&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

c<span class="token punctuation">;</span>				<span class="token comment">// &quot;f-o-o&quot;</span>
d<span class="token punctuation">;</span>				<span class="token comment">// &quot;F.O.O.&quot;</span></code></pre></div><p>Давайте возьмем другой пример: реверсируем строку <code>string</code> (кстати, это довольно тривиальный общий вопрос на  JavaScript собеседованиях!). У массивов <code>array</code>есть метод <code>reverse()</code> осуществляюший изменение по месту, но для строки <code>string</code>такого метода нет:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">a<span class="token punctuation">.</span>reverse<span class="token punctuation">;</span>		<span class="token comment">// undefined</span>

b<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span>
b<span class="token punctuation">;</span>				<span class="token comment">// [&quot;!&quot;,&quot;o&quot;,&quot;O&quot;,&quot;f&quot;]</span></code></pre></div><p>К несчастью, это &quot;одалживание&quot; не сработает с методами изменяющими массив <code>array</code>, потому что строки <code>string</code> неизменяемы и поэтому не могут быть изменены по месту:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// все еще возвращаем объект-обертку String (подробнее в Главе 3)</span>
<span class="token comment">// для &quot;foo&quot; :(</span></code></pre></div><p>Другое временное решение (хак) отконвертировать строку <code>string</code> в массив <code>array</code>, выполнить желаемое действие, и затем отконвертировать обратно в строку <code>string</code>.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> c <span class="token operator">=</span> a
	<span class="token comment">// разбиваем `a` на массив символов</span>
	<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span>
	<span class="token comment">// реверсируем массив символов</span>
	<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// объединяем массив символов обратно в строку</span>
	<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span> <span class="token string">&quot;&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

c<span class="token punctuation">;</span> <span class="token comment">// &quot;oof&quot;</span></code></pre></div><p>Если кажется, что это выглядит безобразно, так и есть. Тем не менее, <em>это работает</em> для простых строк <code>string</code>, так что, если вам нужно &quot;склепать&quot; что-нибудь по быстрому, часто такой подход позволит выполнить работу.</p><p><strong>Предупреждение:</strong> Будьте осторожны! Этот подход <strong>не работает</strong> для строк <code>string</code> со сложными (unicode) символами в них (astral symbols, multibyte characters, etc.). Вам потребуются более сложные библиотеки которые распознают unicode символы для правильного выполнения подобных операций. Подробнее можно посмотреть в работе Mathias Bynens&#x27;: <em>Esrever</em> (<a href="https://github.com/mathiasbynens/esrever">https://github.com/mathiasbynens/esrever</a>).</p><p>Хотя с другой стороны: если вы чаще работаете с вашими &quot;строками&quot;,  интерпритируя их как <em>массивы символов</em>, возможно лучше просто записывать их в массив <code>array</code>вместо строк <code>string</code>.Возможно вы избавите себя от хлопот при переводе строки <code>string</code> в массив <code>array</code>каждый раз. Вы всегда можете вызвать <code>join(&quot;&quot;)</code> для массива <code>array</code> <em>символов</em> когда вам понадобится представление в ивде строки <code>string</code>.</p><h2>Числа</h2><p>В JavaScript есть один числовой тип: <code>number</code>. Этот тип включает в себя как &quot;целые&quot; (&quot;integer&quot;) значения так и десятичные дробные числа. Я заключил &quot;целые&quot; (&quot;integer&quot;) в кавычки, потому что в JS это понятие подвергается критике, поскольку здесь нет реально целых значений, как в других языках программирования. Возможно в будущем это изменится, но сейчас, у нас просто есть тип <code>number</code>для всего.</p><p>Итак, в JS, &quot;целое&quot; (&quot;integer&quot;) это просто числовое значение, которое не имеет десятичной составляющей после запятой . Так нпаример, <code>42.0</code> более может считаться &quot;целым&quot;(&quot;integer&quot;), чем <code>42</code>.</p><p>Как и в большинстве современных языков, включая практически все скриптовые языки, реализация чисел <code>number</code> в JavaScript&#x27;основана на стандарте &quot;IEEE 754&quot;, котороый часто называют &quot;числа с плавающей точкой&quot; (&quot;floating-point&quot;). JavaScript особенно использует формат &quot;двойной степени точности&quot; (как &quot;64-битные в бинарном формате&quot;) этого стандарта.</p><p>В интернете есть множество статей о подробных деталях того, как бинарные числа с плавющей точкой записываются в память, и последствия выбора таких чисел. Т.к. понимание того как работает запись в память не строго необходимо для того чтобы корректно использовать числа <code>number</code> в JS, мы оставим это упражнение для заинтересованного читателя, если вы захотите более детально разобраться со стандартом IEEE 754.</p><h3>Числовой синтаксис</h3><p>Чичловые литералы в JavaScript в большинстве представлены как литералы десятичных дробей. Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42.3</span><span class="token punctuation">;</span></code></pre></div><p>Если целая часть дробного числа - <code>0</code>, можно ее опустить:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0.42</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">.42</span><span class="token punctuation">;</span></code></pre></div><p>Аналогично, если дробная часть после точки <code>.</code>, - <code>0</code>, можно ее опустить:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.0</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42.</span><span class="token punctuation">;</span></code></pre></div><p><strong>Предупреждение:</strong> <code>42.</code> выглядит достаточно необычно, и возможно это не лучшая идея если вы хотите избежать недопонимания со стороны других людей при работе с вашим кодом. Но, в любом случае, это корректная запись.</p><p>По умолчанию, большинство чисел <code>number</code> выводятся как десятичные дроби, с удаленными нулями <code>0</code> в конце дробной части. Так:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.300</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">42.0</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// 42.3</span>
b<span class="token punctuation">;</span> <span class="token comment">// 42</span></code></pre></div><p>Очень большие или очень маленькие числа <code>number</code> по умолчанию выводятся в экспоненциальной форме, также как и результат метода <code>toExponential()</code>, например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">5E10</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span>					<span class="token comment">// 50000000000</span>
a<span class="token punctuation">.</span><span class="token function">toExponential</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;5e+10&quot;</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">*</span> a<span class="token punctuation">;</span>
b<span class="token punctuation">;</span>					<span class="token comment">// 2.5e+21</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> a<span class="token punctuation">;</span>
c<span class="token punctuation">;</span>					<span class="token comment">// 2e-11</span></code></pre></div><p>Т.к. числовые значения <code>number</code> могут быть помещены в объект - обертку <code>Number</code> (подробнее Глава 3), числовые значения <code>number</code> могут получать методы встроенные в <code>Number.prototype</code> (подробнее Глава 3). Например, метод <code>toFixed(..)</code> позволяет вам определить с точностью до скольки знаков после запятой вывести дробную часть:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.59</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;43&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.6&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.59&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.590&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.5900&quot;</span></code></pre></div><p>Заметьте что результат - строковлое <code>string</code> представление числа <code>number</code>, и таким образом <code>0</code>- будет добавлено справа если вам понадобится больше знаков после запятой, чем есть сейчас.</p><p><code>toPrecision(..)</code> похожий метод, но он определяет сколько <em>цифровых знаков</em> должно использоваться в выводимом значении:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42.59</span><span class="token punctuation">;</span>

a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;4e+1&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;43&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.6&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.59&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">5</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.590&quot;</span>
a<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span> <span class="token number">6</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.5900&quot;</span></code></pre></div><p>Вам не обязательно использовать переменные для хранения чисел, чтобы применить эти методы; вы можете применять методы прямо к числовым литералам <code>number</code>. Но, будьте осторожны с оператором <code>.</code>. Т.к. <code>.</code> это еще и числовой оператор, и, если есть такая  возможность, он в первую очередь будет интепритирован как часть числового литерала <code>number</code>, вместо того чтобы получать доступ к свойству.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// неправильный ситнтакс:</span>
<span class="token number">42.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// SyntaxError</span>

<span class="token comment">// это корректное обращение к методам:</span>
<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;42.000&quot;</span>
<span class="token number">0.42</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;0.420&quot;</span>
<span class="token number">42.</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// &quot;42.000&quot;</span></code></pre></div><p><code>42.toFixed(3)</code> неверный синтакс, потому что <code>.</code> станет частью числового литерала <code>42.</code> (такая запись корректна -- смотрите выше!), и тогда оператор <code>.</code> который должен получить доступ к методу <code>.toFixed</code> отсутствует.</p><p><code>42..toFixed(3)</code> работает т.к. первый оператор <code>.</code> часть чилового литерала <code>number</code> второая <code>.</code> оператор доступа к свойству. Но, возможно это выглядит странно, и на самом деле очень редко можно увидеть что-то подобное в реальном JavaScript коде. Фактически, это нестандартно -- применять методы прямо к примитивным значениям. Нестандартно не значит <em>плохо</em> или <em>неправильно</em>.</p><p><strong>Примечание:</strong> Есть библиотеки расширяющие встроенные методы <code>Number.prototype</code> (подробнее Глава 3) для поддержки операций над/с числами <code>number</code>, и в этих случаях, совершенно правильно использовать <code>10..makeItRain()</code> чтобы отключить 10-секундную анимацию денежного дождя, или еще что-нибудь такое же глупое.</p><p>Также технически корректной будет такая запись (заметьте пробел):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">42</span> <span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;42.000&quot;</span></code></pre></div><p>Тем не менее, с числовыми литералами <code>number</code> особенно, <strong>это черезвычайно запутанный стиль кода</strong> и он не преследует иных цедей кроме как запутать разработчиков при работе с кодом (в том числе и вас в будущем). Избегайте этого.</p><p>Числа <code>number</code> также могут быть представлены в экспоненциальной форме, которую обычно используют для представления больших чисел <code>number</code> таких как:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> onethousand <span class="token operator">=</span> <span class="token number">1E3</span><span class="token punctuation">;</span>						<span class="token comment">// means 1 * 10^3</span>
<span class="token keyword">var</span> onemilliononehundredthousand <span class="token operator">=</span> <span class="token number">1.1E6</span><span class="token punctuation">;</span>	<span class="token comment">// means 1.1 * 10^6</span></code></pre></div><p>Числовые литералы <code>number</code> могут быть также выражены в других формах, таких как, двоичная, восьмеричная, и шестнадцатиричная.</p><p>Эти форматы работают в текущей версии JavaScript:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">0xf3</span><span class="token punctuation">;</span> <span class="token comment">// шестнадцатиричная для: 243</span>
<span class="token number">0Xf3</span><span class="token punctuation">;</span> <span class="token comment">// то же самое</span>

<span class="token number">0363</span><span class="token punctuation">;</span> <span class="token comment">// восьмеричная для: 243</span></code></pre></div><p><strong>Примечание:</strong> Начиная с ES6 с включенным <code>strict</code> режимом, восьмеричная форма <code>0363</code> больше не разрешена (смотрите ниже новую форму). Форма <code>0363</code> все еще разрешена в <code>non-strict</code> режиме, но в любом случае нужно прекратить ее использовать, чтобы использовать современный подход (и потому что пора бы использовать <code>strict</code> режим уже сейчас!).</p><p>Для ES6, доступны новые формы записи:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">0o363</span><span class="token punctuation">;</span>		<span class="token comment">// восьмеричная для: 243</span>
<span class="token number">0O363</span><span class="token punctuation">;</span>		<span class="token comment">// то же самое</span>

<span class="token number">0b11110011</span><span class="token punctuation">;</span>	<span class="token comment">// двоичная для: 243</span>
<span class="token number">0B11110011</span><span class="token punctuation">;</span> <span class="token comment">// то же самое</span></code></pre></div><p>И пожалуйста окажите вашим коллегам - разработчикам услугу: никогда не используйте форму вида <code>0O363</code>. <code>0</code> перед заглавной <code>O</code> может лишь вызвать затруднение при чтении кода. Всегда используйте нижний регистр в подобных формах: <code>0x</code>, <code>0b</code>, и <code>0o</code>.</p><h3>Маленькие дробные числа</h3><p>Самый известный побочный эффект от использования бинарной формы чисел с плавающей точкой (которая, как мы помним, справедлива для <strong>всех</strong> языков использующих стандарт IEEE 754 -- не <em>только</em> JavaScript как многие привыкли предполагать) это:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">===</span> <span class="token number">0.3</span><span class="token punctuation">;</span> <span class="token comment">// false</span></code></pre></div><p>Математически, что результатом выражения должно быть <code>true</code>. Почему же в результате получается <code>false</code>?</p><p>Если по простому, представления чисел <code>0.1</code> и <code>0.2</code> в бинарном виде с плавающей точкой не совсем точные, поэтому когда мы их складываем, результат не совсем <code>0.3</code>. Это <strong>действительно</strong> близко: <code>0.30000000000000004</code>, но если сравнение не прошло, &quot;близко&quot; уже не имеет значения.</p><p><strong>Примечание:</strong> Должен ли JavaScript перейти на другую реализацию числового типа <code>number</code> которая имеет точные представления для всех значений? Некоторые так думают. За все годы появлялось много альтернатив. Никакие из них до сих пор не были утверждены, и возможно никогда не будут. Кажется что это также легко, как просто поднять руку и сказать &quot;Да исправьте вы уже этот баг!&quot;, но это вовсе не так. Если бы это было легко, это определенно было бы имправлено намного раньше.</p><p>Сейчас, вопрос в том, что если есть числа <code>number</code> для которых нельзя быть <em>уверенным</em> в их точности, может нам совсем не стоит испльзовать числа <code>number</code>? <strong>Конечно нет.</strong></p><p>Есть несколько случаев применения чисел, где нужно быть осторожными, особенно имея дело с дробными числами. Также есть достаточно (возможно большинство?) случаев когда мы имеем дело только с целыми числами (&quot;integers&quot;), и более того, работаем только с числами максимум до миллиона или триллиона. Такие случаи применения чисел всегда были, и будут, <strong>превосходно безопасными</strong> для проведения числовых операций в JS.</p><p>Но что если нам <em>было</em> нужно сравнить два числа <code>number</code> таких как <code>0.1 + 0.2</code> и <code>0.3</code>, зная что обычный тест на равенство не сработает?</p><p>Самая общепринятая практикаиспользование миниатюрной &quot;ошибки округления&quot; как <em>допуска</em> для сравнения. Это малюсенькое значение часто называют &quot;машинной эпсилон,&quot; которое составляет <code>2^-52</code> (<code>2.220446049250313e-16</code>) для числового типа <code>number</code> в JavaScript.</p><p>В ES6, <code>Number.EPSILON</code> определено заранее этим пороговым значением, так что если вы хотите его использовать, нужно применить полифилл для определения порогового значения для стандартов до-ES6:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">52</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Мы можем использовать это значение <code>Number.EPSILON</code> для проверки двух чисел <code>number</code>на &quot;равенство&quot; (с учетом допуска ошибки округления):</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">numbersCloseEnoughToEqual</span><span class="token punctuation">(</span><span class="token parameter">n1<span class="token punctuation">,</span>n2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span> n1 <span class="token operator">-</span> n2 <span class="token punctuation">)</span> <span class="token operator">&lt;</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0.3</span><span class="token punctuation">;</span>

<span class="token function">numbersCloseEnoughToEqual</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>					<span class="token comment">// true</span>
<span class="token function">numbersCloseEnoughToEqual</span><span class="token punctuation">(</span> <span class="token number">0.0000001</span><span class="token punctuation">,</span> <span class="token number">0.0000002</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// false</span></code></pre></div><p>Максимальное значение числа с плавающей точкой приблизительно <code>1.798e+308</code> (реально огромное число!), определено как <code>Number.MAX_VALUE</code>. Минимальное значение, <code>Number.MIN_VALUE</code> приблизительно <code>5e-324</code>, оно положительное, но очень близко к нулю!</p><h3>Безопасные диапазоны целых чисел</h3><p>Из-за представления чисел <code>number</code>в JS, существует диапазон &quot;безопасных&quot; значений для всех чисел <code>number</code> &quot;integers&quot;, и он существенно меньше значения <code>Number.MAX_VALUE</code>.</p><p>Максимальное целое число, которое может быть &quot;безопасно&quot; представлено (это означает гарантию того, что запрашиваемое значение будет представлено совершенно определенно) это <code>2^53 - 1</code>, что составляет <code>9007199254740991</code>. Если вы добавите запятые, то увидите что это немного больше 9 квадридллионов. Так что это чертовски много для верхнего диапазона чисел <code>number</code>.</p><p>Это значение автоматически предопределенно в ES6, как <code>Number.MAX_SAFE_INTEGER</code>. Ожидаемо, минимальное значение, <code>-9007199254740991</code>, соответственно предопрелено в ES6 как <code>Number.MIN_SAFE_INTEGER</code>.</p><p>Чаще всего JS программы могут столкнуться с такими большими чилами, когда имеют дело с 64-битными ID баз данных, и т.п.. 64-битные не могут быть точно представлены типом <code>number</code>, так что они должны быть записаны (и переданы в/из) JavaScript с помощью строкового <code>string</code> представления.</p><p>Математические операции с ID <code>number</code> значениями (кроме сравнения, которое отлично пройдет со строками <code>string</code>) обычно не выполняются, к счастью. Но если вам <em>необходимо</em> выполнить математическую операцию с очень большими числами, сейчас вы можете использовать утилиту <em>big number</em>. Поддержка больших чисел может быть реализована в будущих стандартах JavaScript.</p><h3>Проверяем является ли число целым</h3><p>Чтобы проверить,является ли число целым, вы можете использовать специальный ES6-метод <code>Number.isInteger(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> <span class="token number">42.000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> <span class="token number">42.3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// false</span></code></pre></div><p>Полифилл для <code>Number.isInteger(..)</code> для стандартов до-ES6:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isInteger</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token keyword">typeof</span> num <span class="token operator">==</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">&amp;&amp;</span> num <span class="token operator">%</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Для проверки на нахождение числа в безопасном диапазоне <em>safe integer</em>, используется ES6-метод  <code>Number.isSafeInteger(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// false</span>
Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span> <span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span></code></pre></div><p>Полифилл для <code>Number.isSafeInteger(..)</code> для стандартов до-ES6:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isSafeInteger<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isSafeInteger</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">num</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span> num <span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
			Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span> num <span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><h3>32-битные целые числа (со знаком)</h3><p>Пока целые числа могут быть приблизительно до 9 квадриллионов (53 бита), есть несколько числовых операторов (например побитовые операторы), которые определены для 32-битных чисел <code>number</code>, так &quot;безопасный диапазон&quot; для чисел <code>number</code> используемый в таких случаях намного меньше.</p><p>Диапазоном является от <code>Math.pow(-2,31)</code> (<code>-2147483648</code>, около -2.1 милллиардов) до <code>Math.pow(2,31)-1</code> (<code>2147483647</code>, около +2.1 миллиардов).</p><p>Чтобы записать число <code>number</code> из переменной <code>a</code> в 32-битное целое число, используем <code>a | 0</code>. Это сработает т.к.  <code>|</code> побитовый оператор и работает только с 32-битными целыми числами (это означает что он будет работать только с 32 битами, а остальные биты будут утеряны). Ну, а &quot;ИЛИ&quot; с нулем побитовый оператор, который не проводит операций с битами.</p><p><strong>Примечание:</strong> Определенные специальные значения (о которых будет расказано далее) такие как <code>NaN</code> и  <code>Infinity</code> не являются &quot;32-битными безопасными значениями&quot; и в случае передачи этих значений побитовому оператору, будет применен абстрактный оператор  <code>ToInt32</code> (смотрите главу 4) результатом которого будет значение<code>+0</code> для последующего применения побитового оператора.</p><h2>Специальные значения</h2><p>Есть несколько специальных значений, которые распространяются на все типы, и с которыми <em>внимательный</em> JS разработчик должен быть осторожен, и использовать их по назначению.</p><h3>Отстуствие значения</h3><p>Для типа <code>undefined</code>, есть только одно значение: <code>undefined</code>. Для типа <code>null</code>, есть только одно значение: <code>null</code>. Итак для них обоих, есть свой тип и свое значение.</p><p>И <code>undefined</code> и <code>null</code> часто считаются взаимозаменяемыми, как либо &quot;пустое&quot; значение, либо его &quot;отсутствие&quot;. Другие разработчики различают их в соответствиис их особенностями. Например:</p><ul><li><code>null</code> пустое значение</li><li><code>undefined</code> остуствующее значение</li></ul><p>Или:</p><ul><li><code>undefined</code> значение пока не присвоено</li><li><code>null</code> значение есть и там ничего не содержится</li></ul><p>Независимо от того, как вы &quot;определяете&quot; и используете эти два значения, <code>null</code> это специальное ключевое слово, не является идентификатором, и таким образом нельзя его использовать для назначения переменной (зачем вообще это делать!?). Как бы там ни было, <code>undefined</code> <em>является</em> (к несчастью) идентификатором. Увы и ах.</p><h3>Undefined</h3><p>В нестрогом режиме non-<code>strict</code>, действительно есть возможность (хоть это и срезвчайно плохая идея!) присваивать значение глобальному идентификатору <code>undefined</code> :</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// очень плохая идея!</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// TypeError!</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p>Как в нестрогом non-<code>strict</code> так и в строгом <code>strict</code> режимах, тем не менее, вы можете создать локальную переменную <code>undefined</code>. Но, еше раз, это ужасная идея!</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token string">&quot;use strict&quot;</span><span class="token punctuation">;</span>
	<span class="token keyword">var</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">undefined</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p><strong>Настоящие друзья никогда не позволят друзьям переназначить <code>undefined</code>.</strong> Никогда.</p><h4>Оператор <code>void</code></h4><p>Пока <code>undefined</code> является встроенным идентификатором который содержит (если только кто-нибудь это не изменил -- см. выше!) встроенное значение <code>undefined</code>, другой способ получить это значение - оператор <code>void</code>.</p><p>Выражение <code>void ___</code> &quot;аннулирует&quot; любое значение, так что результатом выражения всегда будет являться значение <code>undefined</code>. Это выражение не изменяет действующее значение; оно просто дает нам уверенность в том, что мы не получим назад другого значения после применения оператора.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">void</span> a<span class="token punctuation">,</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined 42</span></code></pre></div><p>По соглашению (большей частью из C-языка прогаммирования), для получения только самого значения <code>undefined</code> вместо использования <code>void</code>, вы можете использовать <code>void 0</code> (хотя и понятно что даже <code>void true</code> или любое другое <code>void</code> выражение выполнит то же самое). На практике нет никакой разницы между <code>void 0</code>, <code>void 1</code>, и <code>undefined</code>.</p><p>Но, оператор <code>void</code> может быть полезен в некоторых других обстоятельствах, например, если нужно быть уверенным, что выражение не вернет никакого результата (даже если оно имеет побочный эффект).</p><p>Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// примечание: `APP.ready` поддерживается нашим приложением</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">APP</span><span class="token punctuation">.</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// попробуйте еще раз позже</span>
		<span class="token keyword">return</span> <span class="token keyword">void</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span> doSomething<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">var</span> result<span class="token punctuation">;</span>

	<span class="token comment">// делаем что - нибудь другое</span>
	<span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// есть возможность выполнить задачу прямо сейчас?</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// выполняем следующие задания немедленно right away</span>
<span class="token punctuation">}</span></code></pre></div><p>Здесь, функция <code>setTimeout(..)</code> возвращает числовое значение (уникальный идентификатор интервала таймера, если вы захотите его отменить), но нам нужно применить оператор <code>void</code> чтобы значение, которое вернет функция не было  ложно-положительным  с инструкцией <code>if</code>.</p><p>Многие разработчики  предпочитают выполнять действия по отдельности, что в результате работает так же, но не требует применения оператора <code>void</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">APP</span><span class="token punctuation">.</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// попробуйте еще раз позже</span>
	<span class="token function">setTimeout</span><span class="token punctuation">(</span> doSomething<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Итак, если есть место где существует значение (как результат выражения) , и вы находите полезным получить вместо него <code>undefined</code>, используйте оператор <code>void</code>. Возможно это не должно часто встречаться в ваших программах, но в редких случах, когда это понадобится, это может быть довольно полезным.</p><h3>Специальные числа</h3><p>Тип <code>number</code> включает в себя несколько специальных значений. Рассмотрим каждое более подробно.</p><h4>НЕ Число, Число</h4><p>Любая математическая операция которую выполняют с операндами не являющимися числами <code>number</code> (или значениями которые могут быть интерпритированы как числа <code>number</code>в десятчиной или шестнадцатиричной форме) приведет к ошибке при попытке получить значение чилового типа <code>number</code>, в этом случае вы получите значение <code>NaN</code>.</p><p><code>NaN</code> буквально означает &quot;not a <code>number</code> (&quot;НЕ число&quot;), хотя это название/описание довольно скудное и обманчивое, как мы скоро увидим. Было бы правильнее думать о  <code>NaN</code> как о &quot;неправильном числе,&quot; &quot;ошибочном числе,&quot; или даже &quot;плохом числе,&quot; чем думать о нем как о  &quot;НЕ числе.&quot;</p><p>Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>		<span class="token comment">// NaN</span>

<span class="token keyword">typeof</span> a <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span><span class="token punctuation">;</span>	<span class="token comment">// true</span></code></pre></div><p>Другими словами: &quot;Типом НЕ-числа явдяется число &#x27;number&#x27;!&quot; Ура запутывающим именам и семантике.</p><p><code>NaN</code> навроде &quot;сторожевого значения&quot; (другими словами нормальное значение, которое несет специальный смысл) которое определяет сбой при проведении операции назначения числа <code>number</code>. Эта ошибка, по сути означает следующее: &quot;Я попробовал выполнить математическую операция и произошла ошибка, поэтому, вместо результата, здесь ошибочное число <code>number</code>.&quot;</p><p>Итак, если у вас есть значение в какой-нибудь переменной, и вы хотите проверить, не является ли оно ошибочным числом <code>NaN</code>, вы должно быть думаете что можно просто его сравнить пямо с <code>NaN</code>, как с любым другим значением, например <code>null</code> или <code>undefined</code>. Неа.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

a <span class="token operator">==</span> <span class="token number">NaN</span><span class="token punctuation">;</span>	<span class="token comment">// false</span>
a <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">;</span>	<span class="token comment">// false</span></code></pre></div><p><code>NaN</code> очень особенное значение и оно никогда не будет равно другому значению <code>NaN</code> (т.е., оно не равно самому себе). Фактически, это всего лишь значение, которое не рефлексивно (без возможности идентификации <code>x === x</code>). Итак, <code>NaN !== NaN</code>. Немного странно, да?</p><p>Так как мы <em>можем</em> его проверить, если нельзя сравнить с <code>NaN</code> (т.к. сравнение не сработает)?</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

<span class="token function">isNaN</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre></div><p>Достаточно просто, верно? мы использовали встроенную глобальную функцию, которая называется <code>isNaN(..)</code> и она сообщила нам является значение <code>NaN</code> или нет. Проблема решена!</p><p>Не так быстро.</p><p>У функции <code>isNaN(..)</code> есть большой недостаток. Он появляется при попытках воспринимать значение <code>NaN</code> (&quot;НЕ-Число&quot;) слишком буквально -- вот, вкратце, как это работает: &quot;проверяем то, что нам передали -- либо это не является числом <code>number</code>, либо -- это число <code>number</code>.&quot; Но это не совсем правильно.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// NaN</span>
b<span class="token punctuation">;</span> <span class="token comment">// &quot;foo&quot;</span>

window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true -- упс!</span></code></pre></div><p>Понятно, <code>&quot;foo&quot;</code> буквально <em>НЕ-Число</em>, но и определенно не яляется значением <code>NaN</code>! Этот баг был в JS с самого начала (более 19 лет <em>упс</em>).</p><p>В ES6, наконец была представлена функция: <code>Number.isNaN(..)</code>. Простым полифиллом, чтобы вы могли проверить на значение <code>NaN</code> <em>прямо сейчас</em>, даже в браузерах не поддерживающих-ES6, будет:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isNaN</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>
			<span class="token keyword">typeof</span> n <span class="token operator">===</span> <span class="token string">&quot;number&quot;</span> <span class="token operator">&amp;&amp;</span>
			window<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> n <span class="token punctuation">)</span>
		<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>

Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false -- фуух!</span></code></pre></div><p>Вообще,  мы можем реализовать полифилл <code>Number.isNaN(..)</code> даже проще, если воспользоваться специфической особенностью <code>NaN</code>, которое не равно самому себе. <code>NaN</code> <em>единственное</em> для котрого это справедливо; любое другое значение всегда <strong>равно самому себе</strong>.</p><p>Итак:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Number<span class="token punctuation">.</span>isNaN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Number<span class="token punctuation">.</span><span class="token function-variable function">isNaN</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> n <span class="token operator">!==</span> n<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p>Странно, правда? Но это работает!</p><p><code>NaN</code>могут появляться во многих действующих JS программах, намеренно или случайно. Это действительно хорошая идея проводить надежную проверку, например <code>Number.isNaN(..)</code> если это поддерживается (или полифилл), чтобы распознать их должным образом.</p><p>Если вы все еще используете <code>isNaN(..)</code> в своей программе, плохая новость: в вашей программе <em>есть баг</em>, даже если вы с ним еще не столкнулись!</p><h4>Бесконечности</h4><p>Разработчик пришедшие из традиционных компилируемых языков вроде C, возможно, привыкли видеть ошибку компилирования ли выполнения, например &quot;деление на ноль,&quot; для подобных операций:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre></div><p>Как бы там ни было, в JS, эта операция четко определена, и ее результатом будет являться -- бесконечность <code>Infinity</code> (ну или <code>Number.POSITIVE_INFINITY</code>). Как и ожидается:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// Infinity</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// -Infinity</span></code></pre></div><p>Как вы видите, <code>-Infinity</code> (или <code>Number.NEGATIVE_INFINITY</code>) получается при делении-на-ноль где один из операторов (но не оба!) является отрицательным.</p><p>JS использует вещественное представление чисел (IEEE 754 числа с плавающей точкой, о котором было рассказано ранее), вразрез с чистой математикой, похоже что <em>есть</em> возможность переполнения при выполнении таких операций как сложение или вычитание, и в этом случае результатом будет <code>Infinity</code> или <code>-Infinity</code>.</p><p>Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>	<span class="token comment">// 1.7976931348623157e+308</span>
a <span class="token operator">+</span> a<span class="token punctuation">;</span>						<span class="token comment">// Infinity</span>
a <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">970</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// Infinity</span>
a <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">969</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// 1.7976931348623157e+308</span></code></pre></div><p>Согласно спецификации, если, в результате операции вроде сложения, получается число, превышающее максимальное число, которое может быть представлено, функция IEEE 754 &quot;округления-до-ближайшего&quot; определит, каким должен быть результат. Итак, если проще, <code>Number.MAX_VALUE + Math.pow( 2, 969 )</code> ближе к <code>Number.MAX_VALUE</code> чем к бесконечности <code>Infinity</code>, так что его &quot;округляем вниз,&quot; тогда как <code>Number.MAX_VALUE + Math.pow( 2, 970 )</code> ближе к бесконечности <code>Infinity</code>, поэтому его &quot;округляем вверх&quot;.</p><p>Если слишком много об этом думать, то у вас так скоро голова заболит. Не нужно. Серьезно, перестаньте!</p><p>Если однажды вы перешагнете одну из <em>бесконечностей</em>, в любом случае, назад пути уже не будет. Другими словами, в почти литературной форме, вы можете прийти из действительности в бесконечность, но не из бесконечности в действительность.</p><p>Это фактически философский вопрос: &quot;Что если бесконечность разделить на бесконечность&quot;. Наш наивный мозг скажет что-нибудь вроде &quot;1&quot;, или, может, &quot;бесконечность.&quot; Но ни то, ни другое, не будет верным. И в математике, и в JavaScript, операция <code>Infinity / Infinity</code> не определена. В JS, результатом будет <code>NaN</code>.</p><p>Но, что если любое вещественное положительное число <code>number</code>, разделить на бесконечность <code>Infinity</code>? Это легко! <code>0</code>. А что если вещественное отрицательное число <code>number</code>, разделить на бесконечность <code>Infinity</code>? Об этом в следующей серии, продолжайте читать!</p><h4>Нули</h4><p>Это может смутить математически-думающего читателя, но в JavaScript есть два значения <code>0</code> нормальный ноль (также известных как положительный ноль <code>+0</code>) <em>и</em> отрицательный ноль <code>-0</code>. Прежде чем объяснять почему существует <code>-0</code> , мы должны посмотреть как это работает в JS, потому что это может сбить с толку.</p><p>Кроме того что значение <code>-0</code> может быть буквально присвоено, отрицательный ноль может быть результатом математических операций. Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// -0</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">*</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// -0</span></code></pre></div><p>Отрицательный ноль не может быть получен в результате сложения или вычитания.</p><p>Отрицательный ноль при выводе в консоль разработчика обычно покажет <code>-0</code>, хотя до недавнего времени это не было общепринятым, вы можете узнать что некоторые старые браузеры до сих пор выводят <code>0</code>.</p><p>Как бы там ни было, при попытке преобразования отрицательного нуля в строку, всегда будет выведено <code>&quot;0&quot;</code>, согласно спецификации.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

<span class="token comment">// (некоторые браузеры) выводят в консоль правильное значение</span>
a<span class="token punctuation">;</span>							<span class="token comment">// -0</span>

<span class="token comment">// но спецификация лжет вам на каждом шагу!</span>
a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// &quot;0&quot;</span>
a <span class="token operator">+</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>						<span class="token comment">// &quot;0&quot;</span>
<span class="token function">String</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// &quot;0&quot;</span>

<span class="token comment">// странно, даже JSON введен в заблуждение</span>
<span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// &quot;0&quot;</span></code></pre></div><p>Интересно,что обратная операция (преобразование из строки <code>string</code> в число <code>number</code>) не врет:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token operator">+</span><span class="token string">&quot;-0&quot;</span><span class="token punctuation">;</span>				<span class="token comment">// -0</span>
<span class="token function">Number</span><span class="token punctuation">(</span> <span class="token string">&quot;-0&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// -0</span>
<span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span> <span class="token string">&quot;-0&quot;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// -0</span></code></pre></div><p><strong>Предупреждение:</strong> Поведение <code>JSON.stringify( -0 )</code> по отношению к <code>&quot;0&quot;</code> странное лишь частично, если вы заметите то обратная операция: <code>JSON.parse( &quot;-0&quot; )</code> выведет <code>-0</code> как вы и ожидаете.</p><p>В дополнение к тому что преобразование в строку скрывает реальное значение отрицательного нуля, операторы сравнения также (намеренно) настроены <em>лгать</em>.</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

a <span class="token operator">==</span> b<span class="token punctuation">;</span>		<span class="token comment">// true</span>
<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>

a <span class="token operator">===</span> b<span class="token punctuation">;</span>	<span class="token comment">// true</span>
<span class="token operator">-</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>

<span class="token number">0</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span>		<span class="token comment">// false</span>
a <span class="token operator">&gt;</span> b<span class="token punctuation">;</span>		<span class="token comment">// false</span></code></pre></div><p>Очевидно, если вы хотите различать <code>-0</code> от <code>0</code> в вашем коде, вы не можете просто полагаться на то,что выведет консоль разработчика, так что придется поступить немного хитрее:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isNegZero</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	n <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span> n <span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> n <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">isNegZero</span><span class="token punctuation">(</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>
<span class="token function">isNegZero</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token operator">/</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
<span class="token function">isNegZero</span><span class="token punctuation">(</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">// false</span></code></pre></div><p>Итак, зачем нам нужен отрицательный ноль, вместо обычного значения?</p><p>Есть определенные случаи где разработчики используют величину значения для определения одних данных (например скорость перемещения анимации в кадре) а знак этого числа <code>number</code> для представления других данных (например направление перемещения).</p><p>В этих случаях, как в примере выше, если переменная достигнет нуля и потеряет знак, тогда, вы потеряете информацию о том, откуда она пришла, до того как достигла нулевого значения. Сохранение знака нуля предупреждает потерю этой информации.</p><h3>Специальное равенство</h3><p>Как мы увидели выше, значения <code>NaN</code> и <code>-0</code> ведут себя по--особенному при попытке проверки на равенство. <code>NaN</code> никогда не равно самому себе, так что вы должны использовать метод ES6 <code>Number.isNaN(..)</code> (или полифилл). Аналогично, <code>-0</code> обманывает и притворяется (даже при использовании <code>===</code> строгого равенства -- подробнее в Главе 4) обычным положительным <code>0</code>, так что приходится использовать что-то вроде хаков типа <code>isNegZero(..)</code> как предлогалось выше.</p><p>Для ES6, есть новый метод для проверки двух значений на абсолютное равенство, без всех этих исключений. Он называется <code>Object.is(..)</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">0</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token number">NaN</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// true</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span> b<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// true</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span> b<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// false</span></code></pre></div><p>Есть достаточно простой полифилл для <code>Object.is(..)</code> если ES6 не поддерживается:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Object<span class="token punctuation">.</span>is<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Object<span class="token punctuation">.</span><span class="token function-variable function">is</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v1<span class="token punctuation">,</span> v2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// проверка на `-0`</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> v2 <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> v1 <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">/</span> v2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// проверка на `NaN`</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">!==</span> v1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> v2 <span class="token operator">!==</span> v2<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		<span class="token comment">// любые другие значения</span>
		<span class="token keyword">return</span> v1 <span class="token operator">===</span> v2<span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div><p><code>Object.is(..)</code>, возможно, не должен быть использован в случаях, когда известно что <code>==</code> или <code>===</code> являются <em>безопасными</em> (подробнее в Главе 4 &quot;Преобразование&quot;), как операторы, они, вероятно, более эффективны и просты в применении. <code>Object.is(..)</code> по большей части применяется в специальных случаях проверки на равенство.</p><h2>Значение против Ссылки</h2><p>Какт во многих других языках, значения могут быть присвоены/переданы либо с помощью копирования-по-значению,либо с помощью копирования-по-ссылке oв зависимости от синтаксиса, который вы используете.</p><p>Например, в C++ если вы хотите передать число <code>number</code> переменной в функции и иметь обновленное значение переменной, вы можете объявить параметр функции например <code>int&amp; myNum</code>, и когда вы передадите ему переменную например <code>x</code>, <code>myNum</code> будет <strong>ссылаться на <code>x</code></strong>; ссылки -- это как особые формы указателей, когда вы получаете указатель на другую переменную (как <em>алиас (псевдоним)</em>). Если вы не объявляете ссылочный параметр, переданное значение  <em>всегда</em> будет скопировано, Даэе если это сложный объект.</p><p>В JavaScript, нет указателей, и ссылки работают немного по-другому. вы не можете получить ссылку от одной JS переменной на другую. Это просто невозможно.</p><p>ССылки в JS указывают на (общее) <strong>значение</strong>, так если у вас есть 10 разных ссылок, они всегда будут разными ссылками на одно общее значение; <strong>ни одна из этих ссылок/указателей tне будет указывать друг на друга.</strong></p><p>Более того, в JavaScript, нет никахих синтаксических подсказок которые контролируют как будет происходить присовение/передача по значению или по ссылке. Вместо этого, <em>тип</em> значения <em>полностью</em> контролирует будет ли это значение присвоено с помощью копирования-по-значению,либо с помощью копирования-по-ссылке.</p><p>Давайте продемонстрируем:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// `b` всегда копирует значение из `a`</span>
b<span class="token operator">++</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// 2</span>
b<span class="token punctuation">;</span> <span class="token comment">// 3</span>

<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> d <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// `d` это ссылка на общее значение `[1,2,3]`</span>
d<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span>
d<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span></code></pre></div><p>Простые значения (примитивы) <em>всегда</em> назаначаются/передаются копированием-по-значению: <code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code>,и ES6 <code>symbol</code>.</p><p>Сложные значения -- объекты <code>object</code> (включая массивы <code>array</code>, и все объекты-обертки -- подробнее в Главе 3) и функции <code>function</code> -- <em>всегда</em> всегда делают копию по ссылке при назначении или передаче.</p><p>В примере выше, т.к. <code>2</code> это примитив, <code>a</code> содержит начальную копию этого значения, а переменной <code>b</code> присвоена другая <em>копия</em> значения. При изменении <code>b</code>, вы никоим образом не меняете значение в переменной <code>a</code>.</p><p>Но <strong>оба<code>c</code> и <code>d</code></strong> отдельные ссылки на одно общее значение <code>[1,2,3]</code>, которое является сложным значением. Важно понимать что никто из переменных: ни <code>c</code> ни  <code>d</code> не &quot;обладает&quot; значением <code>[1,2,3]</code> в большей степени -- они оба всего лишь равноправные ссылки на значение. Таким образом, когда мы используем любую ссылку для изменения (<code>.push(4)</code>) актуального общего значения <code>array</code> самого по себе, это влияет только на это общее значение, и обе ссылки будут указываьб на новое измененное значение <code>[1,2,3,4]</code>.</p><p>Раз уж ссылки указывают на сами значения, а не на переменные, вы не можете использовать одну ссылку, чтобы изменить место, куда будет указывать другая ссылка:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>
b<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>

<span class="token comment">// позже</span>
b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3]</span>
b<span class="token punctuation">;</span> <span class="token comment">// [4,5,6]</span></code></pre></div><p>Когда мы делаем присвоение <code>b = [4,5,6]</code>, мы не делаем абсолютно ничего,что могло бы повлиять на то, <em>куда</em> <code>a</code> все еще ссылается (<code>[1,2,3]</code>). Чтобы это выполнить, <code>b</code>  должно указывать на <code>a</code> вместо того,чтобы ссылаться на массив <code>array</code> -- но такой возможности в JS нет!</p><p>Самым распространненым случаем при котором может возникнуть путаница, является использование параметров функции:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span>

	<span class="token comment">// позже</span>
	x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [4,5,6,7]</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]  а не  [4,5,6,7]</span></code></pre></div><p>Когда мы передаем в аргументе переменную <code>a</code>, функция принимает копию <code>a</code> по ссылке для <code>x</code>. <code>x</code> и <code>a</code> разные ссылки на одно общее значение <code>[1,2,3]</code>. Теперь, внутри функции, мы можем использовать ссылку для изменения самого значения (<code>push(4)</code>). Но, когда мы делаем присвоение <code>x = [4,5,6]</code>, мы никак не влияем на то значение, на которое изначально указывала переменная <code>a</code> -- значит, она все еще указывает на (теперь измененное) значение <code>[1,2,3,4]</code>.</p><p>Нельзя с помощью ссылки <code>x</code> изменить место, куда ссылается <code>a</code>. Мы можем лишь изменить содержимое общего значения, на которое указывют <code>a</code> и <code>x</code>.</p><p>Чтобы добиться изменения содержимого переменной <code>a</code> на значение <code>[4,5,6,7]</code>, вы не можете создать и назначить новый массив <code>array</code> -- вы должны изменить существующее значение массива <code>array</code>:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [1,2,3,4]</span>

	<span class="token comment">// позже</span>
	x<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// обнуляем массив по месту</span>
	x<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// [4,5,6,7]</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span>

a<span class="token punctuation">;</span> <span class="token comment">// [4,5,6,7]  а не  [1,2,3,4]</span></code></pre></div><p>Как вы можете видеть, <code>x.length = 0</code> и <code>x.push(4,5,6,7)</code> не создавали но массив <code>array</code>, а изменяли существующий общий массив <code>array</code>. Таким образом, конечно, <code>a</code> ссылается на новое значение <code>[4,5,6,7]</code>.</p><p>Помните: вы не можете напрямую управлять/переопределять тип копирования: по-значению или по-ссылке -- эти правила полностью контролируются типом основного значения.</p><p>Чтобы эффективно передать сложное значение (например массив<code>array</code>) с помощью копирования по-значению, вам понадобится вручную создать его копию, так чтобы переданная ссылка больше не указывала на оригинал. Например:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token function">foo</span><span class="token punctuation">(</span> a<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div><p><code>slice(..)</code> без параметров по умолчанию делает полностью новую (поверхностую) копию массива <code>array</code>. Таким образом, мы передаем ссылку только на скопированный массив <code>array</code>, а значит <code>foo(..)</code> не может повлиять на содержимое <code>a</code>.</p><p>Чтобы выполнить обратное действие -- передать примитивное значение таким способом, что его изменения будут, навроде как ссылка -- вам понадобится обернуть значение в другое сложное значение (<code>object</code>, <code>array</code>, и т.п.), которое <em>может</em> быть передано копированием по-ссылке:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">wrapper</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	wrapper<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">foo</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>

obj<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 42</span></code></pre></div><p>Здесь, <code>obj</code> действует как обертка для примитивного значения в свойстве <code>a</code>. когда мы передаем <code>foo(..)</code>, копия объекта <code>obj</code> передана по ссылке и назначена параметру <code>wrapper</code>. Теперь мы можем использовать ссылку <code>wrapper</code> для доступа к общему объекту, и обновить его свойство. После выполнения функции, при запросе <code>obj.a</code> будет выведено обновленое значение <code>42</code>.</p><p>Если вы захотите передать ссылку на примитивное значение например <code>2</code>, вы можете просто обернуть его в объект-обертку <code>Number</code> (подробнее в Главе 3).</p><p>Это <em>является</em> настоящим копированием по-ссылке для объекта <code>Number</code>, который <em>будет</em> передан функции, но, к несчастью, получение ссылки на общий объект не дает права на изменение общего примитивного значения, как ожидалось:</p><div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	x <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
	x<span class="token punctuation">;</span> <span class="token comment">// 3</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// эквивалентно `Object(a)`</span>

<span class="token function">foo</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, не 3</span></code></pre></div><p>Проблема в том, что лежащее в основе примитивное значение <em>неизменно</em> (то же самое справедливо для <code>String</code> и <code>Boolean</code>). Если объект <code>Number</code> содержит примитивное значение <code>2</code>, это означает, что объект <code>Number</code> не может быть изменен для хранения другого значения; вы можете лишь создать новый объект <code>Number</code> с другим значением.</p><p>Когда <code>x</code> использовано в выражении <code>x + 1</code>, лежащее в основе примитивное значение <code>2</code> распаковано (извлечено) из объекта <code>Number</code> автоматически, значит строка <code>x = x + 1</code> очень незаметно меняет <code>x</code> и вместо ссылки на общий объект <code>Number</code>, переменная <code>x</code> просто содержит примитивное значение <code>3</code> являющееся результатом математического действия <code>2 + 1</code>. Таким образом, <code>b</code> снаружи все еще ссылается на оригинальный неизмененный/неизменный объект <code>Number</code> содержащий значение <code>2</code>.</p><p>Вы <em>можете</em> добавить свойство поверх объекта <code>Number</code> (не изменяя его примитивного значения), так вы сможете обменимваться информацией косвенно через дополнительные свойства.</p><p>В любом случае, это не является общепринятым; и, возможно, большинство разработчиков не считают это хорошей практикой.</p><p>Вместо использования объекта-обертки <code>Number</code> таким способом, возможно, гораздо удобнее использовать обычный, созданный вручную, объект (<code>obj</code>), о котором говорилось в примере ранее. Никто не говорит, что нет разумного использования объекта-обертки <code>Number</code> -- просто возможно предпочтительнее будет использовать примитивное значение в большинстве случаев.</p><p>Ссылки достаточно мощные, но иногда они есть там где вам нужно, а иногда они нужны вам там, где их нет. Единственное влияние которое у вас есть при выборе типа копирования по-ссылке или по-значению это выбор типа самого значения, так что вы должны косвенно влиять на поведение присвоения/передачи путем выбора типа значений.</p><h2>Обзор</h2><p>В JavaScript, массивы <code>array</code> -- простые коллекции значений любого типа с пронумерованными ячейками. Строки <code>string</code> что-то &quot;подобное массивам <code>array</code>&quot;, но у них есть различия в поведении и нужно быть осторожными при использовании строк как массивов <code>array</code>. Числа в JavaScript включают в себя как &quot;целые&quot; значения так и значения с плавющей точкой.</p><p>Среди примитивнх значений есть некоторые специальные значения.</p><p>Тип <code>null</code> имеет только одно значение: <code>null</code>, также как и тип <code>undefined</code> имеет только одно значение -- <code>undefined</code>. <code>undefined</code> -- изначальное стандартное значение в любой переменной или свойстве, если никакое другое значение не представлено. Оператор <code>void</code> позволяет вам получить значение <code>undefined</code> от любого другого значения.</p><p>Числа <code>number</code> включают в себя несколько специальных значений, например <code>NaN</code> (по идее &quot;Не-Число&quot;, но на самом деле более предпочтительно &quot;неправильное число&quot;); бесконечности <code>+Infinity</code> и <code>-Infinity</code>; и <code>-0</code>.</p><p>Простые примитивные изначения (строки <code>string</code>, числа <code>number</code>, и т.п.) назначаются/передаются копированием по-значению, но сложные значения (объекты <code>object</code>, и т.п.) назначаются/передаются копированием по-ссылке. Ссылки в JS не такие как ссылки/указатели в других языках -- они никогда не указывают на другие переменные/ссылки, только на сами значения.</p></article></main><footer class="flex flex-row flex-wrap w-full justify-center items-end p-4"><div class="mx-2"><a href="https://github.com/DmitryVdovichencko"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1.5em" width="1.5em" xmlns="http://www.w3.org/2000/svg"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg> </a></div><div class="mx-2"><a href="https://twitter.com/Dimetrio89"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1.5em" width="1.5em" xmlns="http://www.w3.org/2000/svg"><path d="M928 254.3c-30.6 13.2-63.9 22.7-98.2 26.4a170.1 170.1 0 0 0 75-94 336.64 336.64 0 0 1-108.2 41.2A170.1 170.1 0 0 0 672 174c-94.5 0-170.5 76.6-170.5 170.6 0 13.2 1.6 26.4 4.2 39.1-141.5-7.4-267.7-75-351.6-178.5a169.32 169.32 0 0 0-23.2 86.1c0 59.2 30.1 111.4 76 142.1a172 172 0 0 1-77.1-21.7v2.1c0 82.9 58.6 151.6 136.7 167.4a180.6 180.6 0 0 1-44.9 5.8c-11.1 0-21.6-1.1-32.2-2.6C211 652 273.9 701.1 348.8 702.7c-58.6 45.9-132 72.9-211.7 72.9-14.3 0-27.5-.5-41.2-2.1C171.5 822 261.2 850 357.8 850 671.4 850 843 590.2 843 364.7c0-7.4 0-14.8-.5-22.2 33.2-24.3 62.3-54.4 85.5-88.2z"></path></svg></a></div><div class="mx-2"><a href="https://twitter.com/Dimetrio89"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024" height="1.5em" width="1.5em" xmlns="http://www.w3.org/2000/svg"><path d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zM349.3 793.7H230.6V411.9h118.7v381.8zm-59.3-434a68.8 68.8 0 1 1 68.8-68.8c-.1 38-30.9 68.8-68.8 68.8zm503.7 434H675.1V608c0-44.3-.8-101.2-61.7-101.2-61.7 0-71.2 48.2-71.2 98v188.9H423.7V411.9h113.8v52.2h1.6c15.8-30 54.5-61.7 112.3-61.7 120.2 0 142.3 79.1 142.3 181.9v209.4z"></path></svg></a></div><div class="mx-2"><a href="https://t.me/Dmitry_Vdovichenko"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 448 512" height="1.5em" width="1.5em" xmlns="http://www.w3.org/2000/svg"><path d="M446.7 98.6l-67.6 318.8c-5.1 22.5-18.4 28.1-37.3 17.5l-103-75.9-49.7 47.8c-5.5 5.5-10.1 10.1-20.7 10.1l7.4-104.9 190.9-172.5c8.3-7.4-1.8-11.5-12.9-4.1L117.8 284 16.2 252.2c-22.1-6.9-22.5-22.1 4.6-32.7L418.2 66.4c18.4-6.9 34.5 4.1 28.5 32.2z"></path></svg></a></div></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/ydkjsTypesAndGrammar/you-dont-know-JS-types/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-486ea00c3b91b8f0a40f.js"],"app":["/app-4598599d5dc989cb3c6d.js"],"component---src-pages-404-js":["/component---src-pages-404-js-f498efe64ffcff345a9c.js"],"component---src-pages-articles-tsx":["/component---src-pages-articles-tsx-9cc7a1c87a70b8789025.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-0775cf1dc20666e6f40e.js"],"component---src-pages-projects-tsx":["/component---src-pages-projects-tsx-f2f226e7f47fd3e2665a.js"],"component---src-pages-tags-tsx":["/component---src-pages-tags-tsx-b5397c08a64ed154cae2.js"],"component---src-templates-article-tsx":["/component---src-templates-article-tsx-78c06980dcd84d0a236d.js"],"component---src-templates-tags-tsx":["/component---src-templates-tags-tsx-692a909c115bdeba8608.js"]};/*]]>*/</script><script src="/polyfill-486ea00c3b91b8f0a40f.js" nomodule=""></script><script src="/component---src-templates-article-tsx-78c06980dcd84d0a236d.js" async=""></script><script src="/2af76ce767fe1f5d8aa362c9f068e2f38185524d-f44f3e4c0c25e6e440b6.js" async=""></script><script src="/d7eeaac4-e421a7068fd23f78af03.js" async=""></script><script src="/1bfc9850-24c4e4f8b9c1ce827e99.js" async=""></script><script src="/app-4598599d5dc989cb3c6d.js" async=""></script><script src="/framework-5b393e7059ef32414e1e.js" async=""></script><script src="/webpack-runtime-e42de5cee8763d7eed7b.js" async=""></script></body></html>